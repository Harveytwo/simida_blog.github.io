{"meta":{"title":"思密达的 blog","subtitle":"nanqiang 记录点滴思密达","description":"养成码字记录的习惯哦~~","author":"Nanqiang Lin","url":"http://yoursite.com"},"pages":[{"title":"about","date":"2018-07-25T15:31:02.000Z","updated":"2018-07-25T15:31:46.512Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"我是 about 页面哦哦哦~~思密达"},{"title":"","date":"2018-07-24T15:58:47.480Z","updated":"2018-07-24T15:58:47.480Z","comments":true,"path":"html/index.html","permalink":"http://yoursite.com/html/index.html","excerpt":"","text":"Document 啦啦啦 我是测试的了 但是我是首页噢噢噢噢"},{"title":"","date":"2018-07-24T15:50:59.184Z","updated":"2018-07-24T15:46:18.819Z","comments":true,"path":"html/test02.html","permalink":"http://yoursite.com/html/test02.html","excerpt":"","text":"Document 啦啦啦 我是测试的了"},{"title":"tags","date":"2018-07-25T15:28:11.000Z","updated":"2018-07-25T15:28:11.507Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"egret_demo_wxPlane","slug":"egret-demo-wxPlane","date":"2018-08-07T14:33:42.000Z","updated":"2018-08-07T14:33:43.029Z","comments":true,"path":"2018/08/07/egret-demo-wxPlane/","link":"","permalink":"http://yoursite.com/2018/08/07/egret-demo-wxPlane/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"wx_game_ranking","slug":"wx-game-ranking","date":"2018-08-06T14:33:50.000Z","updated":"2018-08-06T14:33:51.033Z","comments":true,"path":"2018/08/06/wx-game-ranking/","link":"","permalink":"http://yoursite.com/2018/08/06/wx-game-ranking/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"egret_demo_racingCar","slug":"egret-demo-racingCar","date":"2018-07-31T14:18:43.000Z","updated":"2018-07-31T14:25:22.860Z","comments":true,"path":"2018/07/31/egret-demo-racingCar/","link":"","permalink":"http://yoursite.com/2018/07/31/egret-demo-racingCar/","excerpt":"","text":"egret demo racingCar目录游戏玩法目录介绍主要代码讲解 游戏玩法 该笔记记录做一个简单的游戏项目，赛车游戏。 赛车游戏， loading 记载页，加载进来 游戏开始页，点击开始按钮，进入游戏页面 倒计时3、2、1，车灯闪烁，用户左右滑动，小车随着左右移动，躲避路上其他车辆 根据配置，设置开了 10000km，算是完成了游戏，显示有成功的游戏结束页面，如撞到其他车辆，则显示失败的游戏结束页面，可点击再玩一次，返回首页。 这里策划了一个简单的赛测游戏，熟悉 egret 的使用。接下来就开始写代码了。 目录介绍创建游戏项目（不是 eui 额），根据之前学到的 egret 一些知识，新建一些文件和目录。 该项目自定义 loading ui，使用了场景切换的特殊效果（这两个在之前的文章中有写到）。这里有几个文件需要介绍一下: common/Common.ts 这是放一些公共的变量或者函数的，方便开发统一管理 utils/MoveUtil.ts utils 目录是放一些工具类，赛车游戏，需要用到移动车辆，所以创建一个移动的工具类 Data.ts 这是该游戏项目的一些数据 Game.ts 一些该游戏独有的变量或函数，和 Common.ts 相似，不过这个只是针对该项目 上面这些分类，是个人喜欢，你也可以自己根据你的喜好，创建那些类。 common/Common.ts 公共的变量或者函数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849module Common &#123; //获取当前面板 export function curStage(): egret.Stage &#123; return egret.MainContext.instance.stage; &#125; //当前游戏宽度 export function curWidth(): number &#123; return egret.MainContext.instance.stage.stageWidth; &#125; //当前游戏宽度 export function curHeight(): number &#123; return egret.MainContext.instance.stage.stageHeight; &#125; // 根据name关键字创建一个Bitmap对象。name属性请参考resources/resource.json配置文件的内容。 export function createBitmapByName(name: string) &#123; let result = new egret.Bitmap(); let texture: egret.Texture = RES.getRes(name); result.texture = texture; return result; &#125; // gameover 画面弹出 export function gameOver(type, obj, cb) &#123; switch (type) &#123; case 1: egret.Tween .get(obj) .to(&#123; y: 0 &#125;, 500, egret.Ease.circIn) .call(() =&gt; &#123; cb &amp;&amp; cb(); &#125;) break; case 2: egret.Tween .get(obj) .to(&#123; y: -common.curHeight() &#125;, 300, egret.Ease.circIn) .call(() =&gt; &#123; cb &amp;&amp; cb(); &#125;) break; default: break; &#125; &#125;&#125; utils/MoveUtil.ts utils这个类比较长，这里就不粘贴了，代码地址会在后面附上。 Data.ts 游戏相关数据定义 12345678910111213141516171819202122/** * 游戏相关数据 * */class Data &#123; //默认为true,表示是成功的；false表示失败，没有完成任务 public static gameResult: boolean = true; //记录走过的路程距离 public static distanceLength: number = 0; //目标距离 public static targetDistance: number = 10000; //舞台高 // public static stageH: number = 800; //舞台宽 // public static stageW: number = 480; //当前车速度 public static currentSpeedY: number = 6; // 起始车速度 public static startSpeed: number = 6; // 最大速度 public static mostSpeed: number = 36;&#125; Game.ts 这里我只是写了一个点击按钮效果：按钮点击放大动画，移开取消12345678910111213141516171819202122232425module game &#123; /** * 按钮点击放大动画，移开取消 * * @export * @param &#123;egret.TouchEvent&#125; e * @param &#123;*&#125; successCb 成功回调 * @param &#123;*&#125; [cancleCb] 取消回调，可选 */ export function touchAction(e:egret.TouchEvent, successCb, cancleCb?:any) &#123; if (e.type == egret.TouchEvent.TOUCH_BEGIN) &#123; e.currentTarget.scaleX = 1.05; e.currentTarget.scaleY = 1.05; &#125; else if (e.type == egret.TouchEvent.TOUCH_END) &#123; e.currentTarget.scaleX = 1.0; e.currentTarget.scaleY = 1.0; //开始游戏 successCb &amp;&amp; successCb(); &#125; else if (e.type == egret.TouchEvent.TOUCH_RELEASE_OUTSIDE) &#123; e.currentTarget.scaleX = 1.0; e.currentTarget.scaleY = 1.0; cancleCb &amp;&amp; cancleCb(); &#125; &#125;&#125; 主要代码讲解创建了基础类后，就开始写该项目的主要逻辑了。 创建所有的游戏场景 view/*.ts，实现各个场景间的切换，保证可以跳转全部场景 该项目比较简单，就 3 个场景，主要操作是在赛车场景 SceneGame.ts 游戏开始场景 SceneBegin.ts 比较简单，就需要监听开始按钮事件即可 游戏结束场景 SceneEnd.ts 也较简单，监听再来一次事件，且更加用户是否完成任务，显示成功或失败的图标 SceneBegin.ts 和 SceneEnd.ts 这里就不重复了，之前的场景切换写的比较详细了。 主要讲讲 SceneGame.ts梳理一下这页面的主要逻辑： 倒计时 3、2、1 车辆移动 用户左右滑动 计算米数 碰撞检测 游戏结束判断，成功或失败 先创建背景，无缝循环移动的背景，两个背景拼接起来，背景移动，用户车辆不移动，视觉上感觉用户车辆再移动。 12345678910111213141516171819202122232425262728293031private createBg() &#123; this.bg01 = common.createBitmapByName('bg_png'); this.bg02 = common.createBitmapByName('bg_png'); this.bg01.width = this.bg02.width = common.curWidth(); this.bg01.height = this.bg02.height = common.curHeight(); this.addChild(this.bg01); this.addChild(this.bg02); this.addChild(this.carLayer); var distanceCon: egret.Sprite = new egret.Sprite(); var distanceBg = common.createBitmapByName('roadnumBg_png'); distanceCon.addChild(distanceBg); this.addChild(distanceCon); distanceCon.addChild(this.distanceNum); this.distanceNum.text = '0'; this.distanceNum.x = 0; this.distanceNum.y = 36; this.distanceNum.font = RES.getRes('roadnum_fnt'); distanceCon.x = common.curWidth() - distanceBg.width; distanceCon.y = 100; this.bg02.y = -common.curHeight(); this.bg01MoveUtil = new MoveUtil(this.bg01); this.bg02MoveUtil = new MoveUtil(this.bg02); this.bg01MoveUtil.startPos = new egret.Point(0, 0); this.bg01MoveUtil.endPos = new egret.Point(0, common.curHeight()); this.bg02MoveUtil.startPos = new egret.Point(0, -common.curHeight()); this.bg02MoveUtil.endPos = new egret.Point(0, 0); &#125; 创建用户车辆，12345678910111213private createHero() &#123; this.car = common.createBitmapByName('hero_png'); this.carLight = common.createBitmapByName('carLight_png'); this.heroCon.addChild(this.carLight); this.heroCon.addChild(this.car); this.car.x = (this.heroCon.width - this.car.width) + 1; this.car.y = this.carLight.height - 22; this.heroCon.x = common.curWidth() - 200; this.heroCon.y = common.curHeight() - 300; // console.log(this.heroCon.width,car.width) this.addChild(this.heroCon); &#125; 倒计时，使用 tween 动画就可轻松实现了 12345678910111213141516171819202122232425262728293031323334353637383940414243private startTips(cb) &#123; var that = this; var one: egret.Bitmap = common.createBitmapByName('startnum1_png'); var two: egret.Bitmap = common.createBitmapByName('startnum2_png'); var three: egret.Bitmap = common.createBitmapByName('startnum3_png'); this.addChild(one); this.addChild(two); this.addChild(three); one.anchorOffsetX = one.width / 2; two.anchorOffsetX = two.width / 2; three.anchorOffsetX = three.width / 2; one.anchorOffsetY = one.height / 2; two.anchorOffsetY = two.height / 2; three.anchorOffsetY = three.height / 2; one.x = two.x = three.x = common.curWidth() / 2; one.y = two.y = three.y = common.curHeight() / 2; one.alpha = two.alpha = three.alpha = 0; that.startTimeAnim(three, () =&gt; &#123; that.startTimeAnim(two, () =&gt; &#123; that.startTimeAnim(one, () =&gt; &#123; cb &amp;&amp; cb(); &#125;) &#125;) &#125;) &#125; private startTimeAnim(tar, cb) &#123; egret.Tween .get(tar) .to(&#123; alpha: 1, scaleX: 1.35, scaleY: 1.35 &#125;) .to(&#123; scaleX: 1, scaleY: 1 &#125;, 1000, egret.Ease.backInOut) .call(() =&gt; &#123; if (tar.parent) &#123; tar.parent.removeChild(tar); &#125; // tar.alpha = 0; cb(); &#125;); &#125; 我们现在创建了背景、用户车辆、倒计时，接下来，就是游戏开始了，还记得我们每个 场景都有一个 start 方法控制事件监听吧~~这里监听用户左右滑动的操作和监听每一帧触发事件 ENTER_FRAME ，开始记录用户的米数。 123456789101112131415start() &#123; var that = this; this.startTips(() =&gt; &#123; egret.Tween .get(that.carLight, &#123; loop: true &#125;) .to(&#123; alpha: 0 &#125;, 300) .to(&#123; alpha: 1 &#125;, 300); that.touchEnabled = true; that.addEventListener(egret.Event.ENTER_FRAME, that.onEnterFrame, that); that.addEventListener(egret.TouchEvent.TOUCH_BEGIN, that.touchBegin, that); //这里只需要一个设置为true就可以。 that.bg01MoveUtil.getDistance(true); &#125;); &#125; ENTER_FRAME 事件，这个每一帧都触发的事件，在这里监听用户车辆的碰撞、背景移动、随机产生其他车辆、移动和回收清除它们、判断是否游戏结束（成功或失败） 12345678910111213141516171819202122232425private onEnterFrame(e: egret.Event) &#123; // return false; //检测游戏是否结束 if (this.isOver()) &#123; this.gameEnd(); &#125; //随即生产小车 var time: number = egret.getTimer(); if (time - this.preProduceCarTime &gt; Math.floor(Math.random() * 500 + 1500)) &#123; this.randomCreateCar(); this.preProduceCarTime = time; &#125; //移动小车 if (CarFactory.getInstance().liveCarArray.length) &#123; for (var i = CarFactory.getInstance().liveCarArray.length - 1, car: Car; i &gt;= 0; i--) &#123; car = CarFactory.getInstance().liveCarArray[i]; car.setSpeed(Data.currentSpeedY - 2); car.onEnterFrame(); &#125; &#125; this.bg01MoveUtil.onEnterFrame(); this.bg02MoveUtil.onEnterFrame(); this.distanceNum.text = Math.floor(Data.distanceLength).toString(); &#125; 还有一个类，其他车辆的工厂类 CarFactory.ts，可以批量创建和清楚回收车辆。 所有代码看 github 好了，到这里基本学会了，写一个简单的小游戏了。接下来，靠你的 creative idea 写出好玩的游戏了。","categories":[{"name":"egret","slug":"egret","permalink":"http://yoursite.com/categories/egret/"}],"tags":[{"name":"egret","slug":"egret","permalink":"http://yoursite.com/tags/egret/"},{"name":"typescript","slug":"typescript","permalink":"http://yoursite.com/tags/typescript/"},{"name":"gameDemo","slug":"gameDemo","permalink":"http://yoursite.com/tags/gameDemo/"}]},{"title":"typescript_start","slug":"typescript-start","date":"2018-07-29T15:56:46.000Z","updated":"2018-07-29T16:01:46.061Z","comments":true,"path":"2018/07/29/typescript-start/","link":"","permalink":"http://yoursite.com/2018/07/29/typescript-start/","excerpt":"","text":"typescript 入门目录基础进阶 typescript 基础 typescript 入门","categories":[],"tags":[]},{"title":"es6_symbol","slug":"es6-symbol","date":"2018-07-29T15:46:50.000Z","updated":"2018-07-29T15:54:41.568Z","comments":true,"path":"2018/07/29/es6-symbol/","link":"","permalink":"http://yoursite.com/2018/07/29/es6-symbol/","excerpt":"","text":"ES6 的 原始数据类型Symbol目录概述作为属性名的 Symbol实例：消除魔术字符串属性名的遍历 Symbol 的概述 ES5 的对象属性名都是字符串，这容易造成属性名的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin 模式），新方法的名字就有可能与现有方法产生冲突。如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。这就是 ES6 引入Symbol的原因。 ES6 引入了一种新的原始数据类型Symbol，表示独一无二的值。它是 JavaScript 语言的第七种数据类型，前六种是：undefined、null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。 Symbol 值通过Symbol函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的 Symbol 类型。凡是属性名属于 Symbol 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。12345678910111213141516171819202122let s = Symbol();typeof s// \"symbol\"// Symbol函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，为了在控制台显示，或者转为字符串时，比较容易区分。let s1 = Symbol('foo');let s2 = Symbol('bar');s1 // Symbol(foo)s2 // Symbol(bar)s1.toString() // \"Symbol(foo)\"s2.toString() // \"Symbol(bar)\"// Symbol 的返回值时不相等的，只表示当前 Symbol 值的描述// 没有参数的情况let s1 = Symbol();let s2 = Symbol();s1 === s2 // false// 有参数的情况let s1 = Symbol('foo');let s2 = Symbol('foo');s1 === s2 // false 注意，Symbol函数前不能使用new命令，否则会报错。这是因为生成的 Symbol 是一个原始类型的值，不是对象。也就是说，由于 Symbol 值不是对象，所以不能添加属性。基本上，它是一种类似于字符串的数据类型。 Symbol.for()，Symbol.keyFor()有时，我们希望重新使用同一个 Symbol 值，Symbol.for方法可以做到这一点。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个 Symbol 值，否则就新建并返回一个以该字符串为名称的 Symbol 值。 123456789101112131415let s1 = Symbol.for('foo');let s2 = Symbol.for('foo');s1 === s2 // trueSymbol.for(\"bar\") === Symbol.for(\"bar\")// trueSymbol(\"bar\") === Symbol(\"bar\")// false// Symbol.keyFor方法返回一个已登记的 Symbol 类型值的key。let s1 = Symbol.for(\"foo\");Symbol.keyFor(s1) // \"foo\"let s2 = Symbol(\"foo\");Symbol.keyFor(s2) // undefined 注意，Symbol.for()与Symbol()这两种写法，都会生成新的 Symbol。它们的区别是，前者会被登记在全局环境中供搜索，后者不会。Symbol.for()不会每次调用就返回一个新的 Symbol 类型的值，而是会先检查给定的key是否已经存在，如果不存在才会新建一个值。比如，如果你调用Symbol.for(“cat”)30 次，每次都会返回同一个 Symbol 值，但是调用Symbol(“cat”)30 次，会返回 30 个不同的 Symbol 值。 值运算Symbol 值不能与其他类型的值进行运算，会报错。123456let sym = Symbol('My symbol');\"your symbol is \" + sym// TypeError: can't convert symbol to string`your symbol is $&#123;sym&#125;`// TypeError: can't convert symbol to string 但是，Symbol 值可以显式转为字符串。另外，Symbol 值也可以转为布尔值，但是不能转为数值。1234567891011121314let sym = Symbol('My symbol');String(sym) // 'Symbol(My symbol)'sym.toString() // 'Symbol(My symbol)'let sym = Symbol();Boolean(sym) // true!sym // falseif (sym) &#123; // ...&#125;Number(sym) // TypeErrorsym + 2 // TypeError 作为属性名的 Symbol 每一个 Symbol 值都是不相等的，这意味着 Symbol 值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性。这对于一个对象由多个模块构成的情况非常有用，能防止某一个键被不小心改写或覆盖。 12345678910111213let mySymbol = Symbol();// 第一种写法let a = &#123;&#125;;a[mySymbol] = 'Hello!';// 第二种写法let a = &#123; [mySymbol]: 'Hello!'&#125;;// 第三种写法let a = &#123;&#125;;Object.defineProperty(a, mySymbol, &#123; value: 'Hello!' &#125;);// 以上写法都得到同样结果a[mySymbol] // \"Hello!\" 注意，Symbol 值作为对象属性名时，不能用点运算符。1234567const mySymbol = Symbol();const a = &#123;&#125;;a.mySymbol = 'Hello!';a[mySymbol] // undefineda['mySymbol'] // \"Hello!\"// 因为点运算符后面总是字符串，所以不会读取mySymbol作为标识名所指代的那个值，导致a的属性名实际上是一个字符串，而不是一个 Symbol 值。 Symbol 类型还可以用于定义一组常量，保证这组常量的值都是不相等的。123456789const log = &#123;&#125;;log.levels = &#123; DEBUG: Symbol('debug'), INFO: Symbol('info'), WARN: Symbol('warn')&#125;;console.log(log.levels.DEBUG, 'debug message');console.log(log.levels.INFO, 'info message'); 实例：消除魔术字符串 魔术字符串指的是，在代码之中多次出现、与代码形成强耦合的某一个具体的字符串或者数值。风格良好的代码，应该尽量消除魔术字符串，改由含义清晰的变量代替。 12345678910111213141516171819202122232425262728function getArea(shape, options) &#123; let area = 0; switch (shape) &#123; case 'Triangle': // 魔术字符串 area = .5 * options.width * options.height; break; /* ... more code ... */ &#125; return area;&#125;getArea('Triangle', &#123; width: 100, height: 100 &#125;); // 魔术字符串// 字符串Triangle就是一个魔术字符串。它多次出现，与代码形成“强耦合”，不利于将来的修改和维护。// 消除魔法字符串const shapeType = &#123; triangle: 'Triangle'&#125;;function getArea(shape, options) &#123; let area = 0; switch (shape) &#123; case shapeType.triangle: area = .5 * options.width * options.height; break; &#125; return area;&#125;getArea(shapeType.triangle, &#123; width: 100, height: 100 &#125;);// 把Triangle写成shapeType对象的triangle属性，这样就消除了强耦合。 如果仔细分析，可以发现shapeType.triangle等于哪个值并不重要，只要确保不会跟其他shapeType属性的值冲突即可。因此，这里就很适合改用 Symbol 值。 上面代码中，除了将shapeType.triangle的值设为一个 Symbol，其他地方都不用修改。 123const shapeType = &#123; triangle: Symbol()&#125;; 属性名的遍历 Symbol 作为属性名，该属性不会出现在for…in、for…of循环中，也不会被Object.keys()、Object.getOwnPropertyNames()、JSON.stringify()返回。但是，它也不是私有属性，有一个Object.getOwnPropertySymbols方法，可以获取指定对象的所有 Symbol 属性名。 Object.getOwnPropertySymbols方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。 12345678910const obj = &#123;&#125;;let a = Symbol('a');let b = Symbol('b');obj[a] = 'Hello';obj[b] = 'World';const objectSymbols = Object.getOwnPropertySymbols(obj);objectSymbols// [Symbol(a), Symbol(b)] 下面是另一个例子，Object.getOwnPropertySymbols方法与for…in循环、Object.getOwnPropertyNames方法进行对比的例子。 123456789101112131415const obj = &#123;&#125;;let foo = Symbol(\"foo\");Object.defineProperty(obj, foo, &#123; value: \"foobar\",&#125;);for (let i in obj) &#123; console.log(i); // 无输出&#125;Object.getOwnPropertyNames(obj)// []Object.getOwnPropertySymbols(obj)// [Symbol(foo)] 另一个新的 API，Reflect.ownKeys方法可以返回所有类型的键名，包括常规键名和 Symbol 键名。 12345678let obj = &#123; [Symbol('my_key')]: 1, enum: 2, nonEnum: 3&#125;;Reflect.ownKeys(obj)// [\"enum\", \"nonEnum\", Symbol(my_key)] 由于以 Symbol 值作为名称的属性，不会被常规方法遍历得到。我们可以利用这个特性，为对象定义一些非私有的、但又希望只用于内部的方法。 1234567891011121314151617181920212223242526let size = Symbol('size');class Collection &#123; constructor() &#123; this[size] = 0; &#125; add(item) &#123; this[this[size]] = item; this[size]++; &#125; static sizeOf(instance) &#123; return instance[size]; &#125;&#125;let x = new Collection();Collection.sizeOf(x) // 0x.add('foo');Collection.sizeOf(x) // 1Object.keys(x) // ['0']Object.getOwnPropertyNames(x) // ['0']Object.getOwnPropertySymbols(x) // [Symbol(size)] 上面代码中，对象x的size属性是一个 Symbol 值，所以Object.keys(x)、Object.getOwnPropertyNames(x)都无法获取它。这就造成了一种非私有的内部方法的效果。 更多请参考 Symbol ，该篇文章基本是搬运过来的。","categories":[{"name":"js","slug":"js","permalink":"http://yoursite.com/categories/js/"}],"tags":[{"name":"es6","slug":"es6","permalink":"http://yoursite.com/tags/es6/"}]},{"title":"egret_p2_use","slug":"egret-p2-use","date":"2018-07-28T05:56:58.000Z","updated":"2018-07-28T06:27:39.440Z","comments":true,"path":"2018/07/28/egret-p2-use/","link":"","permalink":"http://yoursite.com/2018/07/28/egret-p2-use/","excerpt":"","text":"egret 中使用 p2.js目录导入 p2.js 库p2 物理世界 导入 p2.js 库p2 是一款 2d 的物理引擎，对现实世界有真实的反应，即游戏需要如重力、碰撞、反弹等等复杂的物理效果，需要物理引擎来模拟计算出数据，然后根据得出的数据来渲染游戏画面。 在 libs 目录下新建 physics/ 并放入 p2.js 的相关文件。 在 egretProperties.json 文件中添加 physics 库，执行命令行。 如果是小游戏，需要在 physic.js 中添加 window.p2 = p2，否则会报错 p2 is undefined 123456modules [ &#123; \"name\": \"physics\", \"path\": \"libs/physics\" &#125;] 123// 导入第三方库时，清一下缓存egret clean egret run p2 物理世界p2 是一款 2d 的物理引擎，其物理世界自然就有一个直角坐标系，横坐标轴为 x 轴，纵坐标轴为 y 轴，原点往右的 x 坐标为正数，原点往上的 y 坐标为正数。 p2 与其他的 JavaScript 物理引擎不同的地方在于，p2 的单位坐标为 50像素。简单来说，设 p2 坐标系中的坐标点为 (1, 0) ，则对应的像素坐标为 (50px, 0) 。所以在初始化物体的位置或宽高参数时，为了与 canvas 相匹配，一般会对像素级的数值除以 50得到的数参与物理世界的运算，这一过程常被称为物理世界的显示映射。 想了解更多，参考 p2 乒乓球游戏。 control/P2World.ts这里封装了 p2 创建 plane、矩形和圆形刚体的常用方法。创建物理世界，并每秒钟推进 60 次物理世界计算，暂停物理世界的计算和继续物理世界计算等方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122class P2World &#123; private world: p2.World; constructor(x: number = 0, y: number = -9.82) &#123; this.world = new p2.World(&#123; gravity: [x, y] &#125;); // 设置刚体休眠 this.world.sleepMode = p2.World.BODY_SLEEPING; this.init(); &#125; private init() &#123; this.updateWorld(); &#125; public get theWorld(): p2.World &#123; return this.world; &#125; private getBody(mass: number = 0, type: number = p2.Body.DYNAMIC): p2.Body &#123; var body = new p2.Body(&#123; mass: mass &#125;); body.type = type; body.userData = &#123;&#125;; return body; &#125; public createPlane(angle: number = Math.PI, x: number, y: number): p2.Body &#123; var shape = new p2.Plane(); var body = this.getBody(0, p2.Body.STATIC) body.addShape(shape); body.angle = angle; body.position[0] = x; body.position[1] = y; this.world.addBody(body); return body; &#125; /** * 矩形刚体 * * @param &#123;number&#125; width 宽 * @param &#123;number&#125; height 高 * @param &#123;number&#125; [type=p2.Body.DYNAMIC] * @param &#123;number&#125; [angle=0] * @returns &#123;p2.Body&#125; * @memberof P2World */ public createBoxBodyShape(width: number, height: number, type: number = p2.Body.DYNAMIC, angle: number = 0): p2.Body &#123; var body = this.getBody(1, type); var shape: p2.Shape = new p2.Box(&#123; width: width, height: height &#125;); body.addShape(shape); body.angle = angle; this.world.addBody(body); return body; &#125; /** * 圆形刚体 * * @param &#123;number&#125; radius * @param &#123;number&#125; [type=p2.Body.DYNAMIC] * @returns &#123;p2.Body&#125; * @memberof P2World */ public createCircleBodyShape(radius: number, type: number = p2.Body.DYNAMIC): p2.Body &#123; var body = this.getBody(1, type); var shape: p2.Shape = new p2.Circle(&#123; radius: radius &#125;); body.addShape(shape); this.world.addBody(body); return body; &#125; /** * 更新世界 * * @private * @param &#123;egret.Event&#125; e * @memberof P2World */ private updateWorld() &#123; egret.Ticker.getInstance().register((dt) =&gt; &#123; if (dt &lt; 10) &#123; return; &#125; if (dt &gt; 1000) &#123; return; &#125; this.world.step(dt / 1000); var stageHeight: number = common.curHeight(); var bodys = this.world.bodies; var l = bodys.length; for (var i: number = 0; i &lt; l; i++) &#123; var body: p2.Body = bodys[i]; if (body.userData &amp;&amp; body.userData.skin) &#123; var skin: egret.DisplayObject = body.userData.skin; if (skin) &#123; skin.x = body.position[0] * common.factor(); skin.y = stageHeight - body.position[1] * common.factor(); skin.rotation = 360 - body.angle * 180 / Math.PI; // skin.rotation = body.angle * 180 / Math.PI; // console.log(360 - body.angle * 180 / Math.PI,body.angle * 180 / Math.PI) if (body.sleepState == p2.Body.SLEEPING) &#123; skin.alpha = 0.5; &#125; else &#123; skin.alpha = 1; &#125; &#125; &#125; &#125; &#125;, this); &#125; stopWorld() &#123; egret.Ticker.getInstance().pause(); &#125; resumeWorld() &#123; egret.Ticker.getInstance().resume(); &#125;&#125; 添加物理世界p2 负责提供相关数据， egret 负责渲染图形界面。使用 boxBody.userData.skin = shape; 设置刚体的皮肤。在物理世界计算中，更新 shape 的相关属性即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556private addWorld() &#123; var p2World = new P2World(); this.p2World = p2World; //创建左下向平面用来阻止刚体跑出屏幕 //创建地面 var groundBody = p2World.createPlane(Math.PI * 2, 0, 0); // 创建天花板 // var topWallBody = p2World.createPlane(Math.PI, 0, common.curHeight() / common.factor()); // 创建左边的墙 var leftWallBody = p2World.createPlane(-Math.PI / 2, 0, 0); // 创建右边的墙 var rightWallBody = p2World.createPlane(Math.PI / 2, common.curWidth() / common.factor(), 0); // var boxBody = p2World.createBoxBodyShape(2, 2); var boxBody = p2World.createCircleBodyShape(1); boxBody.position[0] = 3; boxBody.position[1] = (common.curHeight() - 150) / common.factor(); p2World.theWorld.addBody(boxBody) var shape: egret.Shape = new egret.Shape(); shape.graphics.beginFill(0x00ffff); // shape.graphics.drawRoundRect(0, 0, 100, 100, 0, 0); shape.graphics.drawCircle(0, 0, 50); shape.graphics.endFill(); this.addChild(shape); // 设置 sprite 的 anchor 在图形的中心，如果是圆形则不需要设置了 // shape.anchorOffsetX = shape.width / 2; // shape.anchorOffsetY = shape.height / 2; // 另外设置 shape 的 x 和 y，不要在上面画图时设置，那样物理计算会错误。 shape.x = 150; shape.y = 150; boxBody.userData.skin = shape; shape.touchEnabled = true; var arr = [1,-1]; shape.addEventListener(egret.TouchEvent.TOUCH_TAP, ()=&gt;&#123; boxBody.velocity[0] = (Math.random()+5)*2*arr[Math.floor(arr.length*Math.random())]; boxBody.velocity[1] = (Math.random()+5)*2; &#125;,this) //创建墙面的材质 var wallMaterial = new p2.Material(); var ballMaterial = new p2.Material(); groundBody.shapes[0].material = leftWallBody.shapes[0].material = rightWallBody.shapes[0].material = wallMaterial; boxBody.shapes[0].material = ballMaterial; //设置球与墙面的材质约束 var ballWallContactMaterial = new p2.ContactMaterial(ballMaterial, wallMaterial, &#123; friction : 0.3, //摩擦力 restitution : 0.7 //弹性 &#125;); p2World.theWorld.addContactMaterial(ballWallContactMaterial); &#125; 总结 注意 p2 的坐标系和单位，和 canvas 的不同，需要换算。 刚体需要设置相关材料，并设置和其他刚体的碰撞时的 ContactMaterial，然后添加到 world 中。 刚体的运动设置 velocity 熟悉即可，velocity[0] x 轴的速度，velocity[1] y 轴的速度。","categories":[{"name":"egret","slug":"egret","permalink":"http://yoursite.com/categories/egret/"}],"tags":[{"name":"egret","slug":"egret","permalink":"http://yoursite.com/tags/egret/"},{"name":"typescript","slug":"typescript","permalink":"http://yoursite.com/tags/typescript/"}]},{"title":"egret_scene_change","slug":"egret-scene-change","date":"2018-07-28T05:55:51.000Z","updated":"2018-07-28T06:19:22.202Z","comments":true,"path":"2018/07/28/egret-scene-change/","link":"","permalink":"http://yoursite.com/2018/07/28/egret-scene-change/","excerpt":"","text":"egret 场景切换目录游戏页面切换场景切换动画 游戏场景切换在游戏中，一般会有几个场景：游戏开始、游戏中、游戏结束等场景，还有一些道具、关卡选择等等。 在 src 目录下新建： view/SceneChange.ts 场景 01view/SceneChange02.ts 场景 02events/SceneEvent.ts 场景事件类 control/ViewManager.ts 场景管理类 4 个文件， 用来实行简单的场景切换，如下图： view/SceneChange.ts创建场景 01，start() 监听点击事件，点击生成事件类，dispatch 到 ViewManager 类，切换场景，end() 移除点击事件。场景 02 同样，差不多，就不贴代码了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116class SceneChange extends egret.DisplayObjectContainer &#123; public constructor() &#123; super(); this.init(); &#125; private init() &#123; this.createBg(); &#125; public static GAME_START: string = \"gameStart\"; private shp: egret.Shape; private ang: number = 0; private r: number = 30; private textfield: egret.TextField; private button: egret.TextField; //开启监听 public start() &#123; // 点击文字，切换下个场景 this.button.touchEnabled = true; this.button.addEventListener(egret.TouchEvent.TOUCH_TAP, this.onButtonClick, this); &#125; //结束界面，释放监听 public end() &#123; this.button.touchEnabled = false; if (this.button.hasEventListener(egret.TouchEvent.TOUCH_TAP)) this.button.removeEventListener(egret.TouchEvent.TOUCH_TAP, this.onButtonClick, this); &#125; private createBg() &#123; let sky = this.createBitmapByName(\"bg_jpg\"); this.addChild(sky); let stageW = this.StageWidth; let stageH = this.StageHeight; sky.width = stageW; sky.height = stageH; let topMask = new egret.Shape(); topMask.graphics.beginFill(0x000000, 0.5); topMask.graphics.drawRect(0, 0, stageW, 172); topMask.graphics.endFill(); topMask.y = 33; this.addChild(topMask); let icon: egret.Bitmap = this.createBitmapByName(\"egret_icon_png\"); this.addChild(icon); icon.x = 26; icon.y = 33; let line = new egret.Shape(); line.graphics.lineStyle(2, 0xffffff); line.graphics.moveTo(0, 0); line.graphics.lineTo(0, 117); line.graphics.endFill(); line.x = 172; line.y = 61; this.addChild(line); let colorLabel = new egret.TextField(); colorLabel.textColor = 0xffffff; colorLabel.width = stageW - 172; colorLabel.textAlign = \"center\"; colorLabel.text = \"Hello Egret\"; colorLabel.size = 24; colorLabel.x = 172; colorLabel.y = 80; this.addChild(colorLabel); let textfield = new egret.TextField(); this.addChild(textfield); textfield.alpha = 0; textfield.width = stageW - 172; textfield.textAlign = egret.HorizontalAlign.CENTER; textfield.size = 24; textfield.textColor = 0xffffff; textfield.x = 172; textfield.y = 135; this.textfield = textfield; this.button = new egret.TextField(); this.button.text = '点击点击'; this.button.bold = true; this.button.size = 40; this.button.stroke = 2; this.button.strokeColor = 0x00ff00; // this.button.label = \"Click!\"; // this.button.horizontalCenter = 0; // this.button.verticalCenter = 0; this.button.x = (this.StageWidth - this.button.width) / 2; this.button.y = this.StageHeight / 2; this.addChild(this.button); &#125; private createBitmapByName(name: string): egret.Bitmap &#123; let result = new egret.Bitmap(); let texture: egret.Texture = RES.getRes(name); result.texture = texture; return result; &#125; private onButtonClick(e: egret.TouchEvent) &#123; var toScene02Event: SceneEvents = new SceneEvents(SceneEvents.SCENE_CHANGE); toScene02Event.eventType = SceneEvents.TO_SCENE02; toScene02Event.eventObj = this; ViewManager.getInstance().dispatchEvent(toScene02Event); // this.dispatchEventWith(SceneChange.GAME_START); &#125; private _stage: egret.Stage = egret.MainContext.instance.stage; public StageHeight: number = this._stage.stageHeight; public StageWidth: number = this._stage.stageWidth&#125; events/SceneEvent.ts一个事件类，定义事件 name、type、obj，场景切换时，new 一个事件，dispatch 给 ViewManager 类。 12345678910111213class SceneEvents extends egret.Event &#123; public static SCENE_CHANGE:string = \"scene_change\"; public eventType:any;//事件类型 public eventObj:any;//对象 public static TO_SCENE01: string = \"to_scene01\"; public static TO_SCENE02: string = \"to_scene02\"; public static GAME_END: string = \"gameend\"; public constructor(type: string, bubbles: boolean = false, cancelable: boolean = false) &#123; super(type, bubbles, cancelable); &#125;&#125; control/ViewManager.ts场景管理类，场景主要操作都在这里。 创建所有场景，先添加一个场景到 canvas 并开始监听该场景的事件。 初始化场景切换的监听事件 SceneEvents.SCENE_CHANGE 执行 onChangeScene 事件，根据事件类型，切换不同场景 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465class ViewManager extends egret.DisplayObjectContainer &#123; private static instance: ViewManager; // learn 切换场景动画 sceneChange: SceneChange; sceneChange02: SceneChange02; public constructor() &#123; super(); this.init(); &#125; public static getInstance(): ViewManager &#123; if (!ViewManager.instance) &#123; ViewManager.instance = new ViewManager(); &#125; return ViewManager.instance; &#125; private init() &#123; this.sceneChange = new SceneChange(); this.sceneChange02 = new SceneChange02(); this.start(); &#125; //初始，添加游戏开始界面 public start() &#123; this.initListener(); this.addChild(this.sceneChange); this.sceneChange.start(); &#125; //初始化事件监听 private initListener() &#123; // 监听 SceneEvents.SCENE_CHANGE 事件 this.addEventListener(SceneEvents.SCENE_CHANGE, this.onChangeScene, this); &#125; private onChangeScene(e: SceneEvents) &#123; //移除所有子对象 // this.removeChildren(); //判断事件，接下来添加哪个场景在舞台展现 switch (e.eventType) &#123; case SceneEvents.TO_SCENE01: this.toScene01(); break; case SceneEvents.TO_SCENE02: this.toScene02(); break; // case SceneEvents.GAME_END: // this.addChild(this.gameOver); // break; default: break; &#125; &#125; private toScene02() &#123; this.sceneChange02.start(); this.sceneChange.end(); this.addChildAt(this.sceneChange02, 0); this.removeChild(this.sceneChange); &#125; private toScene01() &#123; this.sceneChange.start(); this.sceneChange02.end(); this.addChildAt(this.sceneChange, 0); this.removeChild(this.sceneChange02); &#125;&#125; Main.ts在 Main.ts 中调用 ViewManager 类，添加到 canvas 中 123private createGameScene() &#123; this.addChild(ViewManager.getInstance());&#125; 场景切换动画上面实现了简单的场景切换，接下来可以考虑一下，做一些场景切换的动画。 新建文件： contrl/ScreenMovies.ts 场景切换特效类 ScreenMovies.ts使用 stage 的截图 Bitmap 和 Tween 动画，切换场景的特效，_txnums 取值 卷帘特效 左右切换移动 直接翻 旋转掉落 随机一种 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677module ScreenMovies &#123; //当前舞台 export function MovieStart(_txnums, cb?: any) &#123; //创建一个截图Bitmap // egret.MainContext.instance.stage; var taget = ViewManager.getInstance().curStage(); // egret.MainContext.instance.stage.stageWidth; stage 的高宽 // egret.MainContext.instance.stage.stageHeight; var w = ViewManager.getInstance().curWidth(); var h = ViewManager.getInstance().curHeight() //新建一个group var loadTxGrp = new egret.Sprite(); loadTxGrp.width = w; loadTxGrp.height = h; taget.addChild(loadTxGrp) //循环创建多个截图bitmap 这里num自由设置 var tx1Number = 40; //每个横着的数量 var Xnumber = 5; //高数量自动计算 var Ynumber = tx1Number / Xnumber; for (var i = 0; i &lt; tx1Number; i++) &#123; //计算每个的XY及宽高 var _mcW = w / Xnumber; var _mcH = h / Ynumber; var _mcX = i % Xnumber * _mcW; var _mcY = Math.floor(i / Xnumber) * _mcH; var renderTexture: egret.RenderTexture = new egret.RenderTexture(); var mypic = renderTexture.drawToTexture(taget, new egret.Rectangle(_mcX, _mcY, _mcW, _mcH)); var bmp = new egret.Bitmap; bmp.texture = renderTexture; bmp.anchorOffsetX = _mcW / 2; bmp.anchorOffsetY = _mcH / 2; bmp.x = _mcX + _mcW / 2; bmp.y = _mcY + _mcH / 2; loadTxGrp.addChild(bmp); if (_txnums == 5) &#123; _txnums = Math.ceil(Math.random() * 4) &#125; //开始特效 switch (_txnums) &#123; case 1: var tw = egret.Tween.get(bmp); tw.to(&#123; scaleX: 0, scaleY: 0, alpha: 0, rotation: 359 &#125;, 800, egret.Ease.circIn).call(onComplete, this); break; case 2: var my_x = -w if (!(i % 2)) &#123; my_x = w * 2 &#125; var tw = egret.Tween.get(bmp); tw.to(&#123; x: my_x, alpha: 0 &#125;, 800, egret.Ease.circIn).call(onComplete, this); break; case 3: var tw = egret.Tween.get(bmp); tw.to(&#123; scaleX: 0.2, scaleY: 1, alpha: 0, blurFliter: 0 &#125;, 800, egret.Ease.backInOut).call(onComplete, this); break; case 4: var tw = egret.Tween.get(bmp); tw.to(&#123; alpha: 0 &#125;, 900, egret.Ease.circIn).call(onComplete, this) break; default: var tw = egret.Tween.get(bmp); tw.to(&#123; scaleX: 1, scaleY: 0, alpha: 0 &#125;, 800, egret.Ease.circIn).call(onComplete, this); &#125; &#125; var upNumber = 0; function onComplete(evt: Comment) &#123; upNumber++ if (upNumber == tx1Number) &#123; taget.removeChild(loadTxGrp); cb &amp;&amp; cb(); &#125; &#125; &#125;&#125; 更改 control/ViewManager.ts 中的 toScene01 和 toScene02 函数调用 ScreenMovies.MovieStart 在动画执行完毕后，开启当前场景的事件监听。 1234567891011121314151617private toScene02() &#123; ScreenMovies.MovieStart(5, () =&gt; &#123; this.sceneChange02.start(); &#125;); this.sceneChange.end(); this.addChildAt(this.sceneChange02, 0); this.removeChild(this.sceneChange);&#125;private toScene01() &#123; ScreenMovies.MovieStart(5, () =&gt; &#123; this.sceneChange.start(); &#125;); this.sceneChange02.end(); this.addChildAt(this.sceneChange, 0); this.removeChild(this.sceneChange02);&#125; 好了，到这里场景切换，和场景切换动画都已经实现了。可以开始写场景里面的玩法了咯～～ 总结： 创建文件时，可以按照不同类的功能，放在不同的文件夹里面。如：view/ 是视图类、control/ 是控制类、event/ 是事件类、 common/ 是一些公共类。 创建场景时，先 extends egret.DisplayObjectContainer 容器类，每个场景使用 start 和 end 来开启和移除场景的监听事件。 使用场景动画时，要在动画执行完毕后，再开启新场景的事件监听。","categories":[{"name":"egret","slug":"egret","permalink":"http://yoursite.com/categories/egret/"}],"tags":[{"name":"egret","slug":"egret","permalink":"http://yoursite.com/tags/egret/"},{"name":"typescript","slug":"typescript","permalink":"http://yoursite.com/tags/typescript/"}]},{"title":"egret_loading_ui","slug":"egret-loading-ui","date":"2018-07-25T15:33:37.000Z","updated":"2018-07-28T06:11:48.729Z","comments":true,"path":"2018/07/25/egret-loading-ui/","link":"","permalink":"http://yoursite.com/2018/07/25/egret-loading-ui/","excerpt":"","text":"egret 自定义 loading目录创建项目自定义 loading ui 创建项目和项目结构使用 egretLauncher 创建项目（这里是 game 项目的学习，不怎么使用 eui 项目），项目名 aaa 一般中文名（做个称职的程序员，避免使用中文名）。 项目结构如下： 熟悉重要目录的作用， tsconfig.json 文件是 typescript 编译的配置 egretProperties.json 文件是 egret 项目的相关配置，如：引擎版本、发布为微信小游戏（wxgame）或 h5（web） 的配置、项目引用的模块（modules）配置等 index.html 文件是项目的 html 文件，可以更改游戏 canvas 的大小、canvas 的适配模式（小游戏不支持 showAll 可以改为 fixedWidth ）、canvas 的方向、游戏的帧数、是否开启 fps 和 log（左上角显示）等 libs 目录是我们项目需要用到的一些库，如：p2.js 物理引擎、dragonbones 库等 resource 目录是放置静态资源 src 目录是我们主要阵地，写代码一般都在这里写 自定义 loading uiegret 创建了项目，egret run 就可以运行项目。开始 src 目录下有 3 个文件（ LoadingUI.ts, Main.ts, Platform.ts ），Main.ts 是项目的主入口，LoadingUI.ts 是 loading ui 的页面，所以要自定义就在这里修改，Platform.ts 平台数据接口，这个没管过。更改 LoadingUI.ts 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119class LoadingUI extends egret.Sprite implements RES.PromiseTaskReporter &#123; public constructor() &#123; super(); this.createView(); &#125; private textField: egret.TextField; private uiContainer: egret.DisplayObjectContainer; private img_loadingBg: egret.Bitmap; private img_loading0: egret.Bitmap; private img_loading1: egret.Bitmap; private loadingBg = \"resource/assets/bg.jpg\"; //加载页面背景 private loading0 = \"resource/mySources/loadingCar.png\"; //进度条的条 private loading1 = \"resource/mySources/timenumBg.png\"; //进度条的 条背景 private w: number; private h: number; private r: number; private createView(): void &#123; this.textField = new egret.TextField(); // this.addChild(this.textField); this.textField.y = 300; this.textField.width = 480; this.textField.height = 100; this.textField.textAlign = \"center\"; this.w = egret.Capabilities.boundingClientWidth; //设备的宽 this.h = egret.Capabilities.boundingClientHeight; // 加载背景图片 var urlLoader: egret.URLLoader = new egret.URLLoader(); urlLoader.addEventListener(egret.Event.COMPLETE, this.onComplete, this); urlLoader.dataFormat = egret.URLLoaderDataFormat.TEXTURE; urlLoader.load(new egret.URLRequest(this.loadingBg)); // 加载进度条 var urlLoader: egret.URLLoader = new egret.URLLoader(); urlLoader.addEventListener(egret.Event.COMPLETE, this.onComplete, this); urlLoader.dataFormat = egret.URLLoaderDataFormat.TEXTURE; urlLoader.load(new egret.URLRequest(this.loading0)); // 加载进度条背景 var urlLoader: egret.URLLoader = new egret.URLLoader(); urlLoader.addEventListener(egret.Event.COMPLETE, this.onComplete, this); urlLoader.dataFormat = egret.URLLoaderDataFormat.TEXTURE; urlLoader.load(new egret.URLRequest(this.loading1)); this.img_loadingBg = new egret.Bitmap(); this.img_loading0 = new egret.Bitmap(); this.img_loading1 = new egret.Bitmap(); this.uiContainer = new egret.DisplayObjectContainer(); this.addChild(this.uiContainer); this.addChildAt(this.img_loadingBg, 0); this.addChild(this.img_loading0); this.addChild(this.img_loading1); this.addChild(this.textField); &#125;// 加载完图片进行操作，贴图到 canvas 上 private onComplete(e: egret.Event) &#123; var urlLoader: egret.URLLoader = &lt;egret.URLLoader&gt;e.target; var texture = urlLoader.data; if (urlLoader._request.url == this.loadingBg) &#123; this.img_loadingBg.texture = texture; var bgW = this.img_loadingBg.width; var bgH = this.img_loadingBg.height; console.log(bgW + \"背景宽\"); console.log(bgH + \"背景高\"); console.log(this.w + \"视口宽\"); console.log(this.h + \"视口高\"); if (this.w / 640 &lt; this.h / 1136) &#123; //W this.img_loadingBg.scaleX = 1; this.img_loadingBg.scaleY = this.stage.stageHeight / bgH; &#125; else &#123; //H this.img_loadingBg.scaleY = 1; this.img_loadingBg.scaleX = this.stage.stageWidth / bgW; &#125; &#125; else if (urlLoader._request.url == this.loading0) &#123; this.img_loading0.scale9Grid = new egret.Rectangle(5, 5, 10, 10); this.img_loading0.width = this.stage.stageWidth - 140; this.img_loading0.height = 50; this.img_loading0.texture = texture; this.img_loading0.anchorOffsetX = this.img_loading0.width * 0.5; this.img_loading0.anchorOffsetY = this.img_loading0.height * 0.5; this.img_loading0.x = this.stage.stageWidth / 2; this.img_loading0.y = this.stage.stageHeight - 100; &#125; else if (urlLoader._request.url == this.loading1) &#123; this.img_loading1.scale9Grid = new egret.Rectangle(5, 5, 10, 10); this.img_loading1.width = this.stage.stageWidth - 140; this.img_loading1.height = 50; this.img_loading1.texture = texture; this.img_loading1.anchorOffsetX = this.img_loading1.width * 0.5; this.img_loading1.anchorOffsetY = this.img_loading1.height * 0.5; this.img_loading1.x = this.stage.stageWidth / 2; this.img_loading1.y = this.stage.stageHeight - 100; console.log(this.stage.stageWidth + \"AAAA\" + this.img_loading1.width); &#125; &#125;// 没加载一个文件调用一次 onProgress public onProgress(current: number, total: number): void &#123; // this.textField.text = `阿西吧Loading...$&#123;current&#125;/$&#123;total&#125;`; //进度文字 this.textField.text = \"\" + Math.round((current / total) * 100) + \"%\"; //进度条宽度 if (this.img_loading1 != null) &#123; this.img_loading1.width = 400 * (current / total); &#125; &#125;&#125; 主要是在 createView 方法里面加载图片，然后把 texture 赋值给 Bitmap 就行，进度条的表示在 onProgress 中操作。","categories":[{"name":"egret","slug":"egret","permalink":"http://yoursite.com/categories/egret/"}],"tags":[{"name":"egret","slug":"egret","permalink":"http://yoursite.com/tags/egret/"},{"name":"typescript","slug":"typescript","permalink":"http://yoursite.com/tags/typescript/"}]},{"title":"first","slug":"first","date":"2018-07-23T13:53:08.000Z","updated":"2018-07-24T16:01:38.359Z","comments":true,"path":"2018/07/23/first/","link":"","permalink":"http://yoursite.com/2018/07/23/first/","excerpt":"从事前端工作两年出了，还没怎么写过博客，很是惭愧啊~~所以感觉总是自己的技术进步不大呐！现在开始，使用 github 搞一个个人博客吧！用于记录日常点点… So let’s begin今天先写一些 typescript 的学习笔记","text":"从事前端工作两年出了，还没怎么写过博客，很是惭愧啊~~所以感觉总是自己的技术进步不大呐！现在开始，使用 github 搞一个个人博客吧！用于记录日常点点… So let’s begin今天先写一些 typescript 的学习笔记 后面是啦啦啦啦啦啦啦啦啦啦啦啦","categories":[{"name":"什么","slug":"什么","permalink":"http://yoursite.com/categories/什么/"},{"name":"纳尼","slug":"什么/纳尼","permalink":"http://yoursite.com/categories/什么/纳尼/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"http://yoursite.com/tags/typescript/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-07-23T13:43:21.214Z","updated":"2018-07-25T15:36:40.891Z","comments":true,"path":"2018/07/23/hello-world/","link":"","permalink":"http://yoursite.com/2018/07/23/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}